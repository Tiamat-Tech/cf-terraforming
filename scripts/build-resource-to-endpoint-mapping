#!/usr/bin/env ruby

require "yaml"

if ARGV.length != 1
  puts "path to stainless configuration must be provided as the only argument"
  exit 1
end

config = YAML.load_file(ARGV[0])
mappingPath = "internal/app/cf-terraforming/cmd/resource_to_endpoint_mapping.go"
output = ""

def terraform_name(v)
  return v.dig("terraform", "name") || ""
end

def has_subresources(v)
  return !v["subresources"].nil?
end

def list_endpoint(v)
  operation = v.dig("methods", "list")
  if operation.nil?
    return nil
  end

  # if we have a hash it means the endpoint has a
  # nested structure and we need the `endpoint` value
  # instead of just the `list` operation value.
  if operation.is_a?(Hash)
    return nil if !operation.dig("endpoint").start_with?("get")

    return operation.dig("endpoint").delete_prefix("get ")
  end

  return nil if !operation.start_with?("get")
  return operation.delete_prefix("get ")
end

def has_terraform_configured(output, hash)
  hash.each do |k, v|
    next if terraform_name(v) == ""
    next if list_endpoint(v).nil?

    output << "\"cloudflare_#{terraform_name(v)}\": \"#{list_endpoint(v)}\",\n"
    has_terraform_configured(output, v["subresources"]) if has_subresources(v)
  end
end

config["resources"].keys.each do |k, v|
  c = config["resources"][k].dig("subresources")
  next if c.nil?
  has_terraform_configured(output, c)
end


File.write(mappingPath, %Q(
// This file is automatically generated. Any manual edits here will be overwritten on the next update.
package cmd

var resourceToEndpoint = map[string]string{
#{output}
}
))

Kernel.system("gofmt -s -w #{mappingPath}")
